use std::str::FromStr;
use crate::ast;
use crate::ast::*;
use crate::Expr;
use crate::lexer;
use crate::lexer::*;
use crate::interner::*;
use std::borrow::Borrow;
use std::collections::VecDeque;

grammar<'input>(src: &'input str, str_interner: &mut Interner<String>, byte_interner: &mut Interner<Box<[u8]>>);

Tagged<E>: TaggedExpr =
    <l: @L> <rule: E> <r: @R> =>
        TaggedExpr::new(rule, l, r);

pub primary_expression_inner: Expr = {
    "id" => Expr::Id(str_interner.intern::<str>(<>)),
    "int literal" => Expr::IntConst(<>.0, <>.1),
    "float literal" => Expr::FloatConst(<>.0, <>.1),
    "string literal" => Expr::StringConst(byte_interner.intern(&<>)),
    "(" <e:expression_inner> ")" => e
};
primary_expression: TaggedExpr = Tagged<primary_expression_inner>;

postfix_expression_inner: Expr = {
    primary_expression_inner => <>,
    <base:postfix_expression> "[" <offset:expression> "]" => Expr::Index { base, offset, },
    <fun:postfix_expression> "(" ")" => Expr::Call { fun, args: vec![].into_boxed_slice(), },
    <fun:postfix_expression> "(" <args:argument_expression_list> ")" => Expr::Call { fun, args, },
    <expr:postfix_expression> "." <id:"id"> => Expr::Dot { expr, field: str_interner.intern::<str>(id) },
    <expr:postfix_expression> "->" <id:"id"> => Expr::Arrow { expr, field: str_interner.intern::<str>(id) },
    <expr:postfix_expression> "++" => Expr::UnaryOp { expr, unop: UnaryOp::IncPost },
    <expr:postfix_expression> "--" => Expr::UnaryOp { expr, unop: UnaryOp::DecPost },
};
postfix_expression: TaggedExpr = Tagged<postfix_expression_inner>;

argument_expression_list_inner: VecDeque<TaggedExpr> = {
    <expr:assignment_expression> => {
        let mut v = VecDeque::new();
        v.push_front(expr);
        v
    },
    <expr:assignment_expression> "," <tail:argument_expression_list_inner> => {
        let mut tail = tail;
        tail.push_front(expr);
        tail
    }
};

argument_expression_list: Box<[TaggedExpr]> =
    argument_expression_list_inner => <Vec<_> as From<VecDeque<TaggedExpr>>>::from(<>).into_boxed_slice();

unary_expression_inner: Expr = {
    <expr:postfix_expression_inner> => expr,
    "++" <expr:unary_expression> => Expr::UnaryOp { expr, unop: UnaryOp::IncPre, },
    "--" <expr:unary_expression> => Expr::UnaryOp { expr, unop: UnaryOp::DecPre, },
    <unop:unary_operator> <expr:cast_expression> => Expr::UnaryOp { expr, unop, },
    "sizeof" <expr:unary_expression> => Expr::Sizeof { expr, },
    "sizeof" "(" <ty:type_name> ")" => Expr::SizeofType { ty, },
};
unary_expression: TaggedExpr = Tagged<unary_expression_inner>;

unary_operator: UnaryOp = {
    "&" => UnaryOp::Lea,
    "*" => UnaryOp::Deref,
    "+" => UnaryOp::Pos,
    "-" => UnaryOp::Neg,
    "~" => UnaryOp::BitNeg,
    "!" => UnaryOp::Not,
};

cast_expression_inner: Expr = {
    unary_expression_inner => <>,
    "(" <ty:type_name> ")" <expr:cast_expression> => Expr::Cast { ty, expr, },
};
cast_expression: TaggedExpr = Tagged<cast_expression_inner>;

mult_expression_inner: Expr = {
    cast_expression_inner => <>,
    <lhs:mult_expression> "*" <rhs:cast_expression> => Expr::BinOp { lhs, rhs, op: BinOp::Mul, },
    <lhs:mult_expression> "/" <rhs:cast_expression> => Expr::BinOp { lhs, rhs, op: BinOp::Div, },
    <lhs:mult_expression> "%" <rhs:cast_expression> => Expr::BinOp { lhs, rhs, op: BinOp::Mod, },
};
mult_expression: TaggedExpr = Tagged<mult_expression_inner>;

add_expression_inner: Expr = {
    mult_expression_inner => <>,
    <lhs:add_expression> "+" <rhs:mult_expression> => Expr::BinOp { lhs, rhs, op: BinOp::Add, },
    <lhs:add_expression> "-" <rhs:mult_expression> => Expr::BinOp { lhs, rhs, op: BinOp::Sub, },
};
add_expression: TaggedExpr = Tagged<add_expression_inner>;

shift_expression_inner: Expr = {
    add_expression_inner => <>,
    <lhs: shift_expression> "<<" <rhs: add_expression> => Expr::BinOp { lhs, rhs, op: BinOp::LShift },
    <lhs: shift_expression> ">>" <rhs: add_expression> => Expr::BinOp { lhs, rhs, op: BinOp::RShift }
};
shift_expression: TaggedExpr = Tagged<shift_expression_inner>;

relational_expression_inner: Expr = {
    shift_expression_inner => <>,
    <lhs: relational_expression> "<" <rhs: shift_expression> => Expr::BinOp { lhs, rhs, op: BinOp::Lt },
    <lhs: relational_expression> ">" <rhs: shift_expression> => Expr::BinOp { lhs, rhs, op: BinOp::Gt },
    <lhs: relational_expression> "<=" <rhs: shift_expression> => Expr::BinOp { lhs, rhs, op: BinOp::Lte },
    <lhs: relational_expression> ">=" <rhs: shift_expression> => Expr::BinOp { lhs, rhs, op: BinOp::Gte },
};
relational_expression: TaggedExpr = Tagged<relational_expression_inner>;

eq_expression_inner: Expr = {
    relational_expression_inner => <>,
    <lhs: eq_expression> "==" <rhs: relational_expression> => Expr::BinOp { lhs, rhs, op: BinOp::Eq, },
    <lhs: eq_expression> "!=" <rhs: relational_expression> => Expr::BinOp { lhs, rhs, op: BinOp::Neq, },
};
eq_expression: TaggedExpr = Tagged<eq_expression_inner>;

and_expression_inner: Expr = {
    eq_expression_inner => <>,
    <lhs: and_expression> "&" <rhs:eq_expression> => Expr::BinOp { lhs, rhs, op: BinOp::BAnd, },
};
and_expression: TaggedExpr = Tagged<and_expression_inner>;

xor_expression_inner: Expr = {
    and_expression_inner => <>,
    <lhs: xor_expression> "^" <rhs:and_expression> => Expr::BinOp { lhs, rhs, op: BinOp::Xor, },
};
xor_expression: TaggedExpr = Tagged<xor_expression_inner>;

or_expression_inner: Expr = {
    xor_expression_inner => <>,
    <lhs: or_expression> "|" <rhs:xor_expression> => Expr::BinOp { lhs, rhs, op: BinOp::BOr, },
};
or_expression: TaggedExpr = Tagged<or_expression_inner>;

land_expression_inner: Expr = {
    or_expression_inner => <>,
    <lhs: land_expression> "&&" <rhs:or_expression> => Expr::BinOp { lhs, rhs, op: BinOp::LAnd, },
};
land_expression: TaggedExpr = Tagged<land_expression_inner>;

lor_expression_inner: Expr = {
    land_expression_inner => <>,
    <lhs: lor_expression> "||" <rhs:land_expression> => Expr::BinOp { lhs, rhs, op: BinOp::LOr, },
};
lor_expression: TaggedExpr = Tagged<lor_expression_inner>;

ternary_expression_inner: Expr = {
    <cond:lor_expression> "?" <tval:expression> ":" <fval:ternary_expression> =>
        Expr::Ternary { cond, tval, fval, },
    lor_expression_inner => <>,
};
ternary_expression: TaggedExpr = Tagged<ternary_expression_inner>;

assignment_expression_inner: Expr = {
    ternary_expression_inner => <>,
    <lhs:unary_expression> <op:assignment_operator> <rhs:assignment_expression> =>
        Expr::BinOp { lhs, rhs, op, }
};
assignment_expression: TaggedExpr = Tagged<assignment_expression_inner>;

assignment_operator: BinOp = {
    "*=" => BinOp::MulAssign,
    "/=" => BinOp::DivAssign,
    "%=" => BinOp::ModAssign,
    "+=" => BinOp::AddAssign,
    "-=" => BinOp::SubAssign,
    "<<=" => BinOp::LshAssign,
    ">>=" => BinOp::RshAssign,
    "&=" => BinOp::AndAssign,
    "^=" => BinOp::XorAssign,
    "|=" => BinOp::OrAssign,
    "=" => BinOp::Assign,
};

expression_inner: Expr = {
    <argument_expression_list_inner> => {
        if <>.len() == 1 {
            let mut x = <>;
            *x.pop_front().unwrap().expr
        } else {
            let exprs = <Vec<_> as From<VecDeque<TaggedExpr>>>::from(<>).into_boxed_slice();
            Expr::Comma { exprs, }
        }
    }
};
expression: TaggedExpr = Tagged<expression_inner>;

spec_qual_list: TySpecQualList = {
    <spec:type_specifier> <l:spec_qual_list> => {
        let mut l = l;
        l.add_spec(spec)
    },
    <spec:type_specifier> => {
        let mut l = TySpecQualList::new();
        l.add_spec(spec)
    },
    <qual:type_qualifier> <l:spec_qual_list> => {
        let mut l = l;
        l.add_qual(qual)
    },
    <qual:type_qualifier> => {
        let mut l = TySpecQualList::new();
        l.add_qual(qual)
    }
};

ptr_inner: i32 = {
    "*" => 0,
    "*" <quals:type_qualifier_list> => quals,
};

pointer: PtrTy =
    <ps:ptr_inner+> => PtrTy(ps);

abstract_declarator: AbsDecl = {
    pointer => AbsDecl::Ptr(<>),
    direct_abstract_declarator => AbsDecl::Direct(<>),
    <p:pointer> <d:direct_abstract_declarator> => AbsDecl::PtrTo(p, d),
};

direct_abstract_declarator: DirAbsDecl = {
    "(" <ad:abstract_declarator> ")" => 
        DirAbsDecl::AbsDecl(Box::new(ad)),
    "[" "]" => 
        DirAbsDecl::Array(None, None),
    "[" <expr:ternary_expression> "]" => 
        DirAbsDecl::Array(None, Some(expr)),
    <d:direct_abstract_declarator> "[" "]" =>
        DirAbsDecl::Array(Some(Box::new(d)), None),
    <d:direct_abstract_declarator> "[" <expr:ternary_expression> "]" =>
        DirAbsDecl::Array(Some(Box::new(d)), Some(expr)),
    <d:direct_abstract_declarator> "(" <params:parameter_type_list> ")" => 
        DirAbsDecl::Fn(Box::new(d), params),
};

parameter_type_list_inner: VecDeque<Ty> = {
    <ty:type_name> => { 
        let mut x = VecDeque::new();
        x.push_front(ty);
        x
    },
    <ty:type_name> "," <tail:parameter_type_list_inner> => {
        let mut x = tail;
        x.push_front(ty);
        x
    }
};

parameter_type_list: Box<[Ty]> = {
    <parameter_type_list_inner> => <Vec<_> as From<VecDeque<_>>>::from(<>).into_boxed_slice(),
    => Box::new([]),
};

type_qualifier_list: i32 = {
    <q:type_qualifier> => q as i32,
    <l:type_qualifier_list> <q:type_qualifier> => l as i32 | q as i32,
};

type_qualifier: TyQual = {
    "volatile" => TyQual::Volatile,
    "const" => TyQual::Const,
};

type_specifier: TySpec = {
    "unsigned" => TySpec::Unsigned,
    "signed" => TySpec::Signed,
    "long" => TySpec::Long,
    "int" => TySpec::Int,
    "void" => TySpec::Void,
    "char" => TySpec::Char,
    "short" => TySpec::Short,
    "float" => TySpec::Float,
    "double" => TySpec::Double,
    struct_or_union_specifier => <>,
};

type_name: Ty = {
    <sqs:spec_qual_list> => sqs.into_type(),
    <sqs:spec_qual_list> <ad:abstract_declarator> => ad.wrap_type(sqs.into_type()),
};

pub type_name_program: Ty = {
    <sqs:spec_qual_list> "eof" => sqs.into_type(),
    <sqs:spec_qual_list> <ad:abstract_declarator> "eof" => ad.wrap_type(sqs.into_type()), 

};

struct_or_union_specifier: TyKind = {
    <s:struct_or_union> <id:"id"> "{" <decls:struct_declaration_list> "}" =>
        ,
    <s:struct_or_union> "{" <decls:struct_declaration_list> "}" =>
        ,
    <s:struct_or_union> <id:"id"> =>
        ,
};

struct_or_union: StructType = {
    "struct" => StructType::Struct,
    "union" => StructType::Union,
};

struct_declaration_list_inner: VecDeque<StructDeclarator> = {
    struct_declaration => {
        let mut decls = VecDeque::new();
        decls.push_front(<>);
        decls
    }
    <d:struct_declaration> <decls:struct_declaration_list_inner> => {
        let mut decls = decls;
        decls.push_front(d);
        decls
    }
};

struct_declaration_list: Box<[StructDeclarator]> = {
    struct_declaration_list_inner => <Vec<_> as From<VecDeque<_>>>::from(<>).into_boxed_slice()
};

struct_declaration: StructDeclarator = {
    specifier_qualifier_list struct_declarator_list ";" => {},
};

struct_declarator_list_inner: VecDeque<StructDeclarator> = {
    struct_declarator => {
        let mut decls = VecDeque::new();
        decls.push_front(<>);
        decls
    }
    <d:struct_declarator> "," <decls:struct_declarator_list_inner> => {
        let mut decls = decls;
        decls.push_front(d);
        decls
    }
};
struct_declarator_list: Box<[StructDeclarator]> = {
    enumerator_list_inner => <Vec<_> as From<VecDeque<_>>>::from(<>).into_boxed_slice() 
};

struct_declarator: StructDeclarator = {
    declarator => ,
    ":" constant_expression => ,
    declarator ":" constant_expression => ,
};

enum_specifier: TySpec = {
    "enum" "{" enumerator_list "}" => ,
    "enum" <id:"id"> "{" enumerator_list "}" => ,
    "enum" <id:"id"> => {
    },
};

enumerator_list_inner: VecDeque<Enumerator> = {
    enumerator => {
        let mut e = VecDeque::new();
        e.push_front(<>);
        e
    },
    enumerator "," enumerator_list_inner => {

    },
};
enumerator_list: Box<[Enumerator]> = {
    enumerator_list_inner => <Vec<_> as From<VecDeque<_>>>::from(<>).into_boxed_slice() 
};

enumerator: Enumerator = {
    "id" => Enumerator::new(<>, None),
    <id:"id"> "=" <exp:conditional_expression> => Enumerator::new(id, Some(exp)),
};

declarator: Declarator = {
    direct_declarator => Declarator::Direct(<>),
    <p:pointer> <d:direct_declarator> => Declarator::PtrTo(p, d),
};

direct_declarator: DirDecl = {
    "id" => DirDecl::Id(<>),
    "(" <ad:declarator> ")" =>
        DirDecl::Declarator(Box::new(ad)),
    <d:direct_declarator> "[" "]" =>
        DirDecl::Array(Box::new(d), None),
    <d:direct_declarator> "[" <expr:ternary_expression> "]" =>
        DirDecl::Array(Box::new(d), Some(expr)),
    <d:direct_declarator> "(" <params:parameter_type_list> ")" => 
        DirDecl::Fn(Box::new(d), params),
    <d:direct_declarator> "(" ")" => 
        DirDecl::Fn(Box::new(d), Box::new([])),
    <d:direct_declarator> "(" <params:identifier_list> ")" => 
        DirDecl::id_fn(d, params),
};

parameter_type_list: ParamList = {
    parameter_list =>
        ParamList { params: <>, varargs: false, },
    parameter_list "," "..." =>
        ParamList { params: <>, varargs: true, },
};

identifer_list_inner: VecDeque<IValue<String>> = {
    "id" => {
        let mut v = VecDeque::new();
        v.push(<>);
        v
    },
    <id:"id"> "," <tail:identifer_list_inner> => {
        let mut tail = tail;
        tail.push_front(id);
        tail
    },
};
identifer_list: Box<[IValue<String>]> = {
    identifer_list_inner => <Vec<_> as From<VecDeque<_>>>::from(<>).into_boxed_slice(),
};

parameter_list_inner: VecDeque<ParamDeclaration> = {
    parameter_declaration => {
        let mut v = VecDeque::new();
        v.push_front(<>);
        v
    },
    <p:parameter_declaration> "," <tail:parameter_list_inner> => {
        let mut t = tail;
        t.push_front(p);
        t
    },
};
parameter_list: Box<[ParamDeclaration]> = {
    parameter_list_inner => <Vec<_> as From<VecDeque<_>>>::from(<>).into_boxed_slice()
};
parameter_declaration: ParamDeclaration = {
    <spec:declaration_specifiers> <d:declarator> => ParamDeclaration::from_decl(spec, d),
    <spec:declaration_specifiers> <ad:abstract_declarator> => ParamDeclaration::from_abs_decl(spec, ad),
    <spec:declaration_specifiers> => ParamDeclaration::from_spec(spec),
};

initializer: Initializer = {
    assignment_expression => Initializer::Expr(assignment_expression),
    "{" initializer_list "}" => Initializer::Structure(initializer_list),
    "{" initializer_list "," "}" => Initializer::Structure(initializer_list),
};

initializer_list_inner: VecDeque<Initializer> = {
    initializer => {
        let mut v = VecDeque::new();
        v.push_front(<>);
        v
    },
    <p:initializer> "," <tail:initializer_list_inner> => {
        let mut t = tail;
        t.push_front(p);
        t
    },
};
initializer_list: Box<[Initializer]> = {
    initializer_list_inner => <Vec<_> as From<VecDeque<_>>>::from(<>).into_boxed_slice()
};

statement: Statement = {
    labeled_statement => <>,
    compount_statement => <>,
    expression_statement => <>,
    selection_statement => <>,
    iteration_statement => <>,
    jump_statement => <>,
};

labeled_statement: Statement = {
    <id:"id"> ":" <s:statement> => ,
    "case" <exp:ternary_expression> ":" <s:statement> => ,
    "default" ":" <s:statement> => ,
};

compount_statement: Statement = {
    "{" "}" => ,
    "{" statement_list "}" => ,
    "{" declaration_list "}" => ,
    "{" declaration_list statement_list "}" => ,
};

declaration: Declaraton = {

};

declaration_list_inner: ? = {
    declaration => {
        let mut v = VecDeque::new();
        v.push_front(<>);
        v
    },
    <p:declaration> "," <tail:declaration_list_inner> => {
        let mut t = tail;
        t.push_front(p);
        t
    },
};
declaration_list: Box<[?]> = {
    declaration_list_inner => <Vec<_> as From<VecDeque<_>>>::from(<>).into_boxed_slice()
};

statement_list_inner: VecDeque<Statement> = {
    statement => {
        let mut v = VecDeque::new();
        v.push_front(<>);
        v
    },
    <p:statement> "," <tail:statement_list_inner> => {
        let mut t = tail;
        t.push_front(p);
        t
    },
};
statement_list: Box<[Statement]> = {
    statement_list_inner => <Vec<_> as From<VecDeque<_>>>::from(<>).into_boxed_slice()
};

expression_statement: Statement = {
    ";" => ,
    expresson ";" => ,
};

selection_statement: Statement = {
    "if" "(" <e:expression> ")" <s:statement> => ,
    "if" "(" <e:expression> ")" <true_branch:statement> "else" <false_branch:statement> => ,
    "switch" "(" <e:expression> ")" <s:statement> => ,
};

iteration_statement: Statement = {
    "while" "(" <e:expression> ")" <s:statement> => ,
    "do" <s:statement> "while" "(" <e:expression> ")" ";" => ,
    "for" "(" <decl:expression_statement> <cond:expression_statement> ")" <s:statement> => ,
    "for" "(" <decl:expression_statement> <cond:expression_statement> <last:expression> ")" <s:statement> => ,
};

jump_statement: Statement = {
    "goto" <id:"id"> ";" => ,
    "continue" ";" => ,
    "break" ";" => ,
    "return" ";" => ,
    "return" <e:expression> ";" => ,
};

translation_unit_inner: VecDeque<?> = {
    external_declaration => {
        let mut v = VecDeque::new();
        v.push_front(<>);
        v
    },
    <p:external_declaration> <tail:translation_unit> => {
        let mut t = tail;
        t.push_front(p);
        t
    },
};
translation_unit: Box<[TranslationUnit]> = {
    translation_unit_inner => <Vec<_> as From<VecDeque<_>>>::from(<>).into_boxed_slice()
};

external_declaration: TranslationUnit = {
    function_definition => ,
    declaration => ,
};

function_definition: ? = {
    declaration_specifiers declarator declaration_list compount_statement => ,
    declaration_specifiers declarator compount_statement => ,
    declarator declaration_list compount_statement => ,
    declarator compount_statement => ,
};

storage_class_specifier: StorageClassSpec = {
    "register" => StorageClassSpec::Register,
    "typedef" => StorageClassSpec::Typedef,
    "extern" => StorageClassSpec::Extern,
    "static" => StorageClassSpec::Static,
    "auto" => StorageClassSpec::Auto,
};

declaration_specifiers: = {
    storage_class_specifier =>
        DeclSpec::new().add_storage_class_spec(<>),
    <s:storage_class_specifier> <ds:declaration_specifiers> => 
        ds.add_storage_class_spec(s),
    type_specifier =>
        DeclSpec::new().add_type_spec(<>),
    <t:type_specifier> <ds:declaration_specifiers> => 
        ds.add_type_spec(t), 
    type_qualifier => 
        DeclSpec::new().add_type_qual(<>),
    <q:type_qualifier> <ds:declaration_specifiers> => 
        ds.add_type_qual(q),
};

extern {
    type Location = usize;
    type Error = lexer::LexError;

    enum lexer::Tok<'input> {
        "auto" => Tok::KWAuto,
        "break" => Tok::KWBreak,
        "const" => Tok::KWConst,
        "case" => Tok::KWCase,
        "char" => Tok::KWChar,
        "continue" => Tok::KWContinue,
        "default" => Tok::KWDefault,
        "do" => Tok::KWDo,
        "double" => Tok::KWDouble,
        "else" => Tok::KWElse,
        "enum" => Tok::KWEnum,
        "extern" => Tok::KWExtern,
        "float" => Tok::KWFloat,
        "for" => Tok::KWFor,
        "goto" => Tok::KWGoto,
        "if" => Tok::KWIf,
        "int" => Tok::KWInt,
        "long" => Tok::KWLong,
        "register" => Tok::KWRegister,
        "return" => Tok::KWReturn,
        "short" => Tok::KWShort,
        "signed" => Tok::KWSigned,
        "sizeof" => Tok::KWSizeof,
        "static" => Tok::KWStatic,
        "struct" => Tok::KWStruct,
        "switch" => Tok::KWSwitch,
        "typedef" => Tok::KWTypedef,
        "union" => Tok::KWUnion,
        "unsigned" => Tok::KWUnsigned,
        "void" => Tok::KWVoid,
        "volatile" => Tok::KWVolatile,
        "while" => Tok::KWWhile,
        "int literal" => Tok::Int(<(i128, lexer::IntType)>),
        "float literal" => Tok::Float(<(f64, lexer::FloatType)>),
        "string literal" => Tok::String(<Box<[u8]>>),
        "char literal" => Tok::Char(<u8>),
        "id" => Tok::Id(<&'input str>),
        "..." => Tok::Ellipsis,
        ">>=" => Tok::RightAssign,
        "<<=" => Tok::LeftAssign,
        "+=" => Tok::AddAssign,
        "-=" => Tok::SubAssign,
        "*=" => Tok::MulAssign,
        "/=" => Tok::DivAssign,
        "%=" => Tok::ModAssign,
        "&=" => Tok::AndAssign,
        "^=" => Tok::XorAssign,
        "|=" => Tok::OrAssign,
        "=" => Tok::Assign,
        ">>" => Tok::RightSh,
        "<<" => Tok::LeftSh,
        "++" => Tok::Inc,
        "--" => Tok::Dec,
        "->" => Tok::Arrow,
        "&&" => Tok::LAnd,
        "||" => Tok::LOr,
        "<" => Tok::Lt,
        "<=" => Tok::Lte,
        ">" => Tok::Gt,
        ">=" => Tok::Gte,
        "==" => Tok::Eq,
        "!=" => Tok::Neq,
        ";" => Tok::Semicolon,
        "[" => Tok::BrackOpen,
        "]" => Tok::BrackClose,
        "{" => Tok::BraceOpen,
        "}" => Tok::BraceClose,
        "(" => Tok::ParOpen,
        ")" => Tok::ParClose,
        "," => Tok::Comma,
        ":" => Tok::Colon,
        "." => Tok::Dot,
        "!" => Tok::LNot,
        "~" => Tok::BNot,
        "-" => Tok::Sub,
        "+" => Tok::Add,
        "*" => Tok::Mul,
        "/" => Tok::Div,
        "%" => Tok::Mod,
        "^" => Tok::Xor,
        "|" => Tok::BOr,
        "&" => Tok::BAnd,
        "?" => Tok::Qmark,
        "eof" => Tok::EOF,
    }
}
